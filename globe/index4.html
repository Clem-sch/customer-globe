<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Customer Globe</title>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #fff;
  font-family: system-ui, Arial, sans-serif;
}

#wrap {
  width: 100%;
  height: 100vh;
  position: relative;
}

#globe {
  width: 100%;
  height: 100%;
}

#controls {
  position: absolute;
  top: 14px;
  left: 14px;
  display: flex;
  gap: 6px;
  z-index: 10;
}

#controls button {
  background: rgba(0,0,0,0.7);
  color: #fff;
  border: none;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 12px;
}

#controls button:hover { background: rgba(0,0,0,0.85); }
#controls button.active { outline: 2px solid rgba(255,255,255,0.7); }
</style>
</head>

<body>
<div id="wrap">
  <div id="controls">
    <button data-mode="global">Global</button>
    <button data-mode="usa">USA</button>
    <button data-mode="both">Both</button>
    <button data-mode="none">None</button>
  </div>

  <div id="globe"></div>
</div>

<script type="module">
import Globe from "https://esm.sh/globe.gl@2";
import * as THREE from "https://esm.sh/three@0.160.0";
import { mesh } from "https://esm.sh/topojson-client@3";

// =========================
// SETTINGS / TOGGLES
// =========================
const MAP_MODE = "coast"; // keep "coast"

// URL mode: ?mode=global|usa|both|none
const params = new URLSearchParams(location.search);
const MODE = (params.get("mode") || "both").toLowerCase();

const SHOW_CUSTOMERS_GLOBAL = (MODE === "global" || MODE === "both");
const SHOW_CUSTOMERS_USA    = (MODE === "usa"    || MODE === "both");

// Layers
const SHOW_CUSTOMER_POINTS = true;
const SHOW_CUSTOMER_RINGS  = false;
const SHOW_COUNTRY_FILL    = true;
const HOVER_ONLY_ACTIVE    = true;
const SHOW_ARCS            = true;

// =========================
// FILES
// =========================
const GLOBAL_JSON = "../data/points.json";
const USA_JSON    = "../data/pointsUSA.json";

const COUNTRIES_TOPO = "./countries-110m.json";
const LAND_TOPO      = "./land-110m.json";
const COUNTRIES_GEO  = "./countries_iso110.geojson";

// =========================
// STYLING
// =========================
const OCEAN_COLOR   = "#eef2f7";
const COUNTRY_COLOR = "rgba(20,20,20,0.06)";
const ACTIVE_COLOR  = "rgba(20,20,20,0.22)";
const LINE_COLOR    = "rgba(0,0,0,1)";
const LINE_WIDTH    = 1;

const CUSTOMER_POINT_ALT = 0.0001;
const CUSTOMER_POINT_RADIUS = 0.55;

const RING_ALT = 0.025;

// Arcs (moving gaps)
const ARC_STROKE = 0.25;
const H_TARGET = 0.12;
const H_MAX    = 0.42;  // a bit higher to avoid NZ/AU cutting
const P        = 1.25;

// =========================
// HELPERS
// =========================
async function fetchJson(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`Fetch failed ${url} (HTTP ${r.status})`);
  return await r.json();
}

function normIso(v){ return (v ?? "").trim().toUpperCase(); }
function normName(v){ return (v ?? "").trim(); }

// =========================
// BUTTONS
// =========================
const btns = [...document.querySelectorAll("#controls button")];
btns.forEach(b => {
  if (b.dataset.mode === MODE) b.classList.add("active");
  b.onclick = () => {
    const m = b.dataset.mode;
    const u = new URL(location.href);
    u.searchParams.set("mode", m);
    location.href = u.toString();
  };
});

// =========================
// INIT GLOBE
// =========================
const root = document.getElementById("globe");
const globe = Globe()(root).backgroundColor("rgba(0,0,0,0)");

// performance: cap pixel ratio
globe.renderer().setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));

const mat = globe.globeMaterial();
mat.color = new THREE.Color(OCEAN_COLOR);
mat.emissive = new THREE.Color("#ffffff");
mat.emissiveIntensity = 0.06;
mat.transparent = true;
mat.opacity = 0.9;
mat.side = THREE.FrontSide;
mat.depthWrite = true;

const scene = globe.scene();
scene.add(new THREE.AmbientLight(0xffffff, 1.35));
const key = new THREE.DirectionalLight(0xffffff, 1.0);
key.position.set(2,1,1);
scene.add(key);

globe.atmosphereColor("#c7d6ff");
globe.atmosphereAltitude(0.06);

const controls = globe.controls();
controls.autoRotate = false;
controls.enableDamping = true;
controls.dampingFactor = 0.08;

// Desktop: zoom only with CTRL. Mobile: pinch zoom enabled.
const isTouch = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
controls.enableZoom = isTouch ? true : false;

window.addEventListener("keydown", e => {
  if (!isTouch && e.key === "Control") controls.enableZoom = true;
});
window.addEventListener("keyup", e => {
  if (!isTouch && e.key === "Control") controls.enableZoom = false;
});
  


// =========================
// LOAD DATA
// =========================
const [customersGlobal, customersUSA, geo, landTopo, countriesTopo] = await Promise.all([
  SHOW_CUSTOMERS_GLOBAL ? fetchJson(GLOBAL_JSON) : Promise.resolve([]),
  SHOW_CUSTOMERS_USA    ? fetchJson(USA_JSON)    : Promise.resolve([]),
  SHOW_COUNTRY_FILL     ? fetchJson(COUNTRIES_GEO) : Promise.resolve({features: []}),
  fetchJson(LAND_TOPO),
  fetchJson(COUNTRIES_TOPO)
]);

const customers = [
  ...customersGlobal.map(d => ({...d, group: "global"})),
  ...customersUSA.map(d => ({...d, group: "usa"}))
];

// Active sets (normalized!)
const activeIso = new Set(customers.map(d => normIso(d.iso3)).filter(Boolean));
const activeNames = new Set(customers.map(d => normName(d.name)).filter(Boolean));

// Use raw coords in coast mode (no grid snapping)
const custLat = d => (d.raw_lat ?? d.lat);
const custLng = d => (d.raw_lng ?? d.lng);

// hubs
const hubDE = customers.find(d => normIso(d.iso3) === "DEU" || normName(d.name) === "Germany");
const hubUS = customers.find(d => normIso(d.iso3) === "USA" || normName(d.name) === "United States");

// =========================
// CUSTOMER POINTS
// =========================
if (SHOW_CUSTOMER_POINTS) {
  globe.pointsData(customers)
    .pointLat(custLat)
    .pointLng(custLng)
    .pointAltitude(CUSTOMER_POINT_ALT)
    .pointRadius(CUSTOMER_POINT_RADIUS)
    .pointColor(d => d.color);
} else {
  globe.pointsData([]);
}

// =========================
// RINGS
// =========================
if (SHOW_CUSTOMER_RINGS) {
  globe.ringsData(customers)
    .ringLat(custLat)
    .ringLng(custLng)
    .ringAltitude(RING_ALT)
    .ringColor(d => [d.color, "rgba(0,0,0,0)"])
    .ringMaxRadius(() => 2.8)
    .ringPropagationSpeed(0.8)
    .ringRepeatPeriod(2200);
} else {
  globe.ringsData([]);
}

// =========================
// ARCS (two hubs, one layer)
// =========================
if (SHOW_ARCS) {
  const arcs = customers
    .filter(d => (d.group === "usa" ? hubUS : hubDE))
    .filter(d => (d.group === "usa" ? d !== hubUS : d !== hubDE))
    .map(d => {
      const hub = (d.group === "usa") ? hubUS : hubDE;
      return {
        startLat: custLat(hub),
        startLng: custLng(hub),
        endLat: custLat(d),
        endLng: custLng(d),
        group: d.group
      };
    });

  globe.arcsData(arcs)
    .arcStartLat(d => d.startLat)
    .arcStartLng(d => d.startLng)
    .arcEndLat(d => d.endLat)
    .arcEndLng(d => d.endLng)
    .arcColor(d => d.group === "usa"
      ? "rgba(255,80,80,0.70)"
      : "rgba(80,130,255,0.75)"
    )
    .arcStroke(ARC_STROKE)
    .arcAltitude(d => {
      const dist = Math.hypot(d.endLat - d.startLat, d.endLng - d.startLng);
      const t = Math.max(0, Math.min(1, dist / 140));
      return H_TARGET + (H_MAX - H_TARGET) * Math.pow(t, P);
    })
    // dashed + moving gaps
    .arcDashLength(0.9)
    .arcDashGap(0.05)
    .arcDashAnimateTime(3600);
} else {
  globe.arcsData([]);
}

// =========================
// COUNTRY FILL + HOVER
// =========================
if (SHOW_COUNTRY_FILL) {
  globe.polygonsData(geo.features)
    .polygonAltitude(0.003)
    .polygonCapColor(f => {
      const iso  = normIso(f?.properties?.ISO_A3);
      const name = normName(f?.properties?.ADMIN ?? f?.properties?.NAME);

      const isActive =
        (iso && iso !== "-99" && activeIso.has(iso)) ||
        (name && activeNames.has(name));

      return isActive ? ACTIVE_COLOR : COUNTRY_COLOR;
    })
    .polygonSideColor(() => "rgba(0,0,0,0)")
    .polygonStrokeColor(() => "rgba(0,0,0,0)")
    .polygonLabel(f => {
      const iso  = normIso(f?.properties?.ISO_A3);
      const name = normName(f?.properties?.ADMIN ?? f?.properties?.NAME);

      const isActive =
        (iso && iso !== "-99" && activeIso.has(iso)) ||
        (name && activeNames.has(name));

      if (!isActive && HOVER_ONLY_ACTIVE) return null;
      return `<div style="background:rgba(0,0,0,.8);color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;">${name}</div>`;
    });
} else {
  globe.polygonsData([]);
}

// =========================
// COAST + BORDERS (paths)
// =========================
let lines = [];
const coastObj = landTopo.objects.land || Object.values(landTopo.objects)[0];
lines = lines.concat(mesh(landTopo, coastObj).coordinates || []);

const borderObj = countriesTopo.objects.countries || Object.values(countriesTopo.objects)[0];
lines = lines.concat(mesh(countriesTopo, borderObj, (a,b)=>a!==b).coordinates || []);

globe.pathsData(lines)
  .pathPoints(d => d)
  .pathPointLat(p => p[1])
  .pathPointLng(p => p[0])
  .pathColor(() => LINE_COLOR)
  .pathStroke(LINE_WIDTH);

</script>
</body>
</html>
